1
00:00:00,00 --> 00:00:05,790
Could you create a programming language for AI pair programmers or maybe as an agents 

2
00:00:05,790 --> 00:00:10,440
as code sort of system using the new OpenAI strawberry?

3
00:00:10,460 --> 00:00:16,190
In this quick video, I'm exploring flexible based programming languages, specifically 

4
00:00:16,230 --> 00:00:20,850
document style programming languages. We're looking at grammars and passes. Let's 

5
00:00:20,850 --> 00:00:21,110
get into it.

6
00:00:22,200 --> 00:00:26,900
For context, I'm building an AI workflow designer, and we can see one of the designs 

7
00:00:26,900 --> 00:00:30,950
here for my YouTube launch, which is when I'm publishing a video. 

8
00:00:30,960 --> 00:00:35,890
for instance, I might want to find the chapters in a transcript and then turn them 

9
00:00:36,700 --> 00:00:38,670
into clickable links in the YouTube descrip.

10
00:00:38,700 --> 00:00:43,600
As an example, I've got this video from last week where I have a YouTube description 

11
00:00:43,600 --> 00:00:46,710
with chapters and related videos, and all of this was done through the workflow.

12
00:00:46,730 --> 00:00:52,230
Now the workflow was created using this little document that I created called YouTube 

13
00:00:52,230 --> 00:00:57,480
Launch Optimizer, and I'm just showing the old version. It's basically a coding language. 

14
00:00:57,480 --> 00:01:03,660
It's an internal DSL. And as I would change values within this language and press 

15
00:01:03,660 --> 00:01:07,560
save, it would generate the screen that you're seeing down below.

16
00:01:07,660 --> 00:01:12,800
I wanna build dozens of coding languages or domain specific languages designed for 

17
00:01:12,830 --> 00:01:18,110
working with large language models. So what I did was I started writing a new version 

18
00:01:18,170 --> 00:01:24,380
of it, and I used my GPT workflow engine to write a lot of this code based off this 

19
00:01:24,380 --> 00:01:25,550
one as an example. 

20
00:01:25,560 --> 00:01:30,680
the key differences is that the one on the right is an internal DSL. So it has access 

21
00:01:30,680 --> 00:01:35,510
to variables. It has access to methods. The one on the left doesn't, it's an external 

22
00:01:35,510 --> 00:01:40,310
DSL. So that sort of stuff wouldn't work. But there's benefits in that I now have 

23
00:01:40,310 --> 00:01:45,380
control over how the language looks. If I want to add new concepts to the language, 

24
00:01:45,380 --> 00:01:47,690
it's a lot easier with the version on the left.

25
00:01:47,700 --> 00:01:51,970
When I'm working with the older technique, these methods actually get called. This 

26
00:01:51,970 --> 00:01:57,910
would save the document to a database and to adjacent file in an Astro website and 

27
00:01:57,910 --> 00:02:02,350
just re-render the screens, whereas the one on the left is going to use more of an 

28
00:02:02,350 --> 00:02:06,250
action space approach, which will still have the save and the saved, 

29
00:02:06,260 --> 00:02:11,480
and we can add in other concepts like Save to CrewAI If I wanna automate a workflow.

30
00:02:11,500 --> 00:02:17,400
Now after building this DSL using a workflow that I developed specifically for creating 

31
00:02:17,430 --> 00:02:21,420
DSLs, I thought it'd be time to start looking at the documentation. 

32
00:02:21,430 --> 00:02:26,920
I created both an examples of how different things are meant to work and a rules 

33
00:02:26,920 --> 00:02:31,660
document. And we can see a visualization of the rules document right here where I'm 

34
00:02:31,660 --> 00:02:36,550
talking about different data types, how parameters are meant to be dealt with in 

35
00:02:36,550 --> 00:02:39,730
different elements, how containers work. 

36
00:02:39,990 --> 00:02:44,320
I've developed all this information and we're going to use it as seed for open, AI's 

37
00:02:44,320 --> 00:02:45,460
strawberry model.

38
00:02:45,500 --> 00:02:51,490
Now we came over to chat GPT, and I've got this o1-preview set up and I've put in 

39
00:02:51,490 --> 00:02:56,950
the word read, and then I've taken the documentation that we've got. Here's all the 

40
00:02:56,950 --> 00:02:58,630
DSL rules 

41
00:02:58,660 --> 00:03:01,270
and here's all the DSL examples. 

42
00:03:01,290 --> 00:03:05,190
Now I haven't written anything else, but we can see here we've got a chain of thought 

43
00:03:05,190 --> 00:03:06,400
for 18 seconds. 

44
00:03:06,400 --> 00:03:11,800
in my last video that I did six use cases on strawberry, one of the things I noticed 

45
00:03:11,800 --> 00:03:15,580
was that not always did it do much better. It'd do a little bit better, it'd go a 

46
00:03:15,580 --> 00:03:21,180
bit more detailed. But the one thing it does so well is this area the reasoning. 

47
00:03:21,210 --> 00:03:25,510
Because this allows you to check how it's thinking. And at any point in this, you 

48
00:03:25,510 --> 00:03:30,910
could also make the decision they made a mistake here and that's what we'll ask them 

49
00:03:30,910 --> 00:03:32,110
to rectify on. 

50
00:03:32,130 --> 00:03:37,730
as we look through this, we got analyzing the DSL details. So it's examining the 

51
00:03:37,730 --> 00:03:39,260
content to understand my intent, 

52
00:03:39,260 --> 00:03:44,620
Then it's reflecting on what's probably the hardest area of this DSL. It's the parameters 

53
00:03:44,620 --> 00:03:49,120
because they support positional named splats, double splats. 

54
00:03:49,130 --> 00:03:52,200
all sorts of structures that have to be dealt with, 

55
00:03:52,230 --> 00:03:53,460
being looked at at the moment. 

56
00:03:53,460 --> 00:03:58,120
So it's crafting the code, crafting the workflow, looking at the YouTube strategy. 

57
00:03:58,130 --> 00:04:02,270
I've only given it rules in this area around parameters and 

58
00:04:02,300 --> 00:04:07,550
data types. Then I gave it the argument rules, which is the positional, the optional, 

59
00:04:07,850 --> 00:04:10,580
the splat, the keywords, and the double splat. 

60
00:04:10,600 --> 00:04:15,160
This is where it started to diverge from Ruby, which has concepts of blocks, but 

61
00:04:15,160 --> 00:04:21,160
I'm seeing that structure as just being a nested hierarchy or a container. And I've 

62
00:04:21,160 --> 00:04:26,260
taught, told it about the order and the constraints. So how can parameters 

63
00:04:26,260 --> 00:04:29,560
on a method definition be set up? 

64
00:04:29,660 --> 00:04:33,780
really simple snippets that associate a rule to an example. 

65
00:04:33,790 --> 00:04:39,330
for instance, a single node that might have a list under it is being shown here. 

66
00:04:39,330 --> 00:04:43,440
So we've got a workflow, there's a single node called settings, and then there's 

67
00:04:43,440 --> 00:04:48,270
a list of setting underneath it. And this is how the definition would look.

68
00:04:48,290 --> 00:04:52,970
I added one other thing into this prompt, and you can see here the definition workflow. 

69
00:04:52,990 --> 00:04:55,590
where that first came from was a GPT 

70
00:04:55,590 --> 00:04:57,830
4o definition, 

71
00:04:56,760 --> 00:05:03,130
which was designing a definition, so this is kind of like a grammar for the DSL was 

72
00:05:03,130 --> 00:05:05,940
firstly designed in ChatGPT 4o 

73
00:05:06,360 --> 00:05:11,660
got a few mistakes there, so I took that over and manually altered it over here. 

74
00:05:12,590 --> 00:05:17,900
So for instance, the workflow should be able to take a name, a parameter called name, 

75
00:05:17,930 --> 00:05:22,880
and it should just take up the first position. After that, there can be a node called 

76
00:05:22,880 --> 00:05:27,530
description, which will take a parameter called description as well in the first 

77
00:05:27,530 --> 00:05:28,190
position. 

78
00:05:28,190 --> 00:05:33,200
we've got the settings. And after that, a node called setting should repeat, and 

79
00:05:33,200 --> 00:05:38,210
it's declarative, meaning whatever the key is, will be derived directly from the 

80
00:05:38,210 --> 00:05:41,750
method name. And after that, there'll be a value.

81
00:05:41,760 --> 00:05:46,540
Now we've got a generated DSL and it's looking very good. I could almost use this 

82
00:05:46,540 --> 00:05:51,640
the way it is. I'm going to click copy here and we'll head over to Visual Studio. 

83
00:05:52,60 --> 00:05:57,700
I have an example that I hand wrote and I put in concepts like multiple sections. 

84
00:05:57,700 --> 00:06:03,160
We can see section one and two and multiple steps. Let's go and put the new one, 

85
00:06:03,160 --> 00:06:08,170
the strawberry one into the system. And here we have them side by side, the old one 

86
00:06:08,170 --> 00:06:12,160
on the left, the new one on the right. So it's modified, a little bit of text, which 

87
00:06:12,160 --> 00:06:18,130
is great. It is taken more my placeholder, prompt ideas and filled 'em out with useful 

88
00:06:18,130 --> 00:06:23,860
names. And it's noticed that I've called it content, which in my older one before 

89
00:06:23,860 --> 00:06:28,660
I would load that from a file. So I have file concepts here, but it's thought, no, 

90
00:06:28,660 --> 00:06:32,740
this is content. So it's going to do more of a prompt sort of approach. And then 

91
00:06:32,740 --> 00:06:38,410
it's still done. The sections and the steps, it's got good naming conventions for 

92
00:06:38,410 --> 00:06:41,620
section steps, input parameters, what 

93
00:06:41,630 --> 00:06:46,710
a link through to the prompt, which would be up above and the output. And if we go 

94
00:06:46,710 --> 00:06:52,890
down to the bottom, it's just made it a little bit cleaner in the file. Name saving. 

95
00:06:52,290 --> 00:06:53,340
This is looking great. 

96
00:06:53,360 --> 00:06:58,680
let's look at the main prompt that I now wanna work with, and I typed a lot of this 

97
00:06:58,680 --> 00:07:02,490
in by talking into the computer, so there's some grammatical issues. 

98
00:07:02,490 --> 00:07:08,690
I said when I gave you the definition file, which was its own DSL for defining DSLs 

99
00:07:08,690 --> 00:07:15,530
a grammar, I said, the goal is to build other DSLs. And the DSL you've produced is 

100
00:07:15,530 --> 00:07:20,990
spot on. So I've told it or affirmed that what it did above is actually correct.

101
00:07:20,990 --> 00:07:24,590
Next I wanted to explore parsing libraries written in the 

102
00:07:24,590 --> 00:07:30,730
Ruby. So 30 words per item. I need to know whether any of the repositories are old 

103
00:07:30,760 --> 00:07:36,190
because I don't really wanna work with old code that might be unmaintained. I've 

104
00:07:36,190 --> 00:07:41,200
then gone on to tell it that the goal of DSLs is really just to convert it into a 

105
00:07:41,200 --> 00:07:44,160
data format that can be read by a machine. In this case, JSON.

106
00:07:44,360 --> 00:07:50,430
Next, I wanted it to think about merging the data from the DSL with whatever the 

107
00:07:50,430 --> 00:07:55,980
user generated content is with the metadata, such as should a value be an integer 

108
00:07:55,980 --> 00:07:57,30
or a Boolean? 

109
00:07:57,330 --> 00:08:01,890
I've said, ultimately it needs to be used by a JavaScript application because this 

110
00:08:01,890 --> 00:08:07,320
is going to be embedded into Visual Studio and Monaco. So I can use this technology 

111
00:08:07,560 --> 00:08:13,230
either in a web application or within the IDE, but what I don't want it to do is 

112
00:08:13,230 --> 00:08:14,220
start exploring this. 

113
00:08:14,230 --> 00:08:18,760
I've told it explicitly that to think about it, 'cause it needs to know about 

114
00:08:18,760 --> 00:08:25,430
ASTs, LSPs, code completion, linting, all this sort of stuff. But I don't want it 

115
00:08:25,370 --> 00:08:28,850
to go deep. I just need it to be informed. 

116
00:08:28,860 --> 00:08:33,630
I've also told it in the next two lines that I'm probably going to build my own engine 

117
00:08:33,630 --> 00:08:39,360
from scratch. And that means I'll either take inspiration from three or four different 

118
00:08:39,630 --> 00:08:41,640
libraries that are already out there. 

119
00:08:41,660 --> 00:08:46,660
part of the reason is this is quite a simple parser in some respects. It's not like 

120
00:08:46,660 --> 00:08:52,540
a programming language where I need to understand variables or method calls, or even 

121
00:08:52,540 --> 00:08:56,860
the mathematical conventions of three plus five times seven. 

122
00:08:56,660 --> 00:09:01,330
This is more like A XML structure or adjacent structure. It's a hierarchy or document.

123
00:09:01,360 --> 00:09:06,760
the chain of reasoning, it went for 34 seconds. Let's expand that and see what we've 

124
00:09:06,760 --> 00:09:08,820
got. We're examining the definition file 

125
00:09:08,830 --> 00:09:13,930
it understands that. I liked what it came up with. It's evaluating different libraries 

126
00:09:13,930 --> 00:09:19,310
and weighing the pros and cons. It's worked out that it's converting a DSL to JSON. 

127
00:09:19,600 --> 00:09:23,830
It'll craft a parser. It will consider the fact that the schema structure needs to 

128
00:09:23,830 --> 00:09:30,130
be included. It's made itself aware of the JavaScript wrappers for IDE use specifically 

129
00:09:30,130 --> 00:09:30,460
around, 

130
00:09:30,460 --> 00:09:32,630
code completion and syntax highlighting. 

131
00:09:32,660 --> 00:09:37,190
it's now assessing whether we should reverse engineer an existing tool. 

132
00:09:37,190 --> 00:09:40,980
I notice in a lot of the chain of thoughts that it's always doing. This response 

133
00:09:40,980 --> 00:09:44,100
needs to be compliant with OpenAI policies. 

134
00:09:44,130 --> 00:09:48,880
it's probably trying to deal with jail-breaking issues here or other sorts of, 

135
00:09:48,890 --> 00:09:50,130
compliance issues. 

136
00:09:50,330 --> 00:09:53,450
now it's crafting a plan for three libraries. It's evaluating 

137
00:09:53,390 --> 00:09:58,290
tree top Palet and Ripper. It's looking at the maintenance status 

138
00:09:58,160 --> 00:10:03,530
it's basically found this library. We've got a GitHub repo, we've got rack when we've 

139
00:10:03,530 --> 00:10:04,550
got treetop. 

140
00:10:04,530 --> 00:10:08,240
what I liked when I saw this was that this is the sort of grammar I really wanna 

141
00:10:08,240 --> 00:10:11,780
work with. Something really simple and easy to extend. 

142
00:10:11,790 --> 00:10:15,330
Now with the evaluation out of the road, it's looking like it's getting into the 

143
00:10:15,330 --> 00:10:19,890
coding itself. So transforming the json, crafting a parser. 

144
00:10:19,260 --> 00:10:23,520
So it's now explored three different libraries. We've got Parlet Rack and Treetop. 

145
00:10:23,730 --> 00:10:27,630
We've got pros and cons. Most of them are actively maintained, 

146
00:10:27,660 --> 00:10:31,260
It then did the transforming of the DSL to JSON, 

147
00:10:31,330 --> 00:10:35,300
I've written adjacent format already called YouTube Launch Optimizer, 

148
00:10:34,760 --> 00:10:37,210
and we'll just copy over the strawberry version 

149
00:10:37,230 --> 00:10:39,30
The one on the right is strawberry. 

150
00:10:39,330 --> 00:10:42,870
you look at this and it goes well, it doesn't have a type of root and it doesn't 

151
00:10:42,870 --> 00:10:47,520
have a type of node, but it doesn't need 'em because it's implied through the fact 

152
00:10:47,520 --> 00:10:48,990
that it's got a 

153
00:10:48,990 --> 00:10:53,560
definition and it's got nodes. So that's kind of implied just through the wrapper. 

154
00:10:53,560 --> 00:10:58,530
here's where it gets really powerful. So one of the things it did here of having 

155
00:10:58,530 --> 00:11:04,320
the type of node and the repeat, this was actually done by GPT four and it's way 

156
00:11:04,320 --> 00:11:09,360
more accurate in the strawberry. Take for instance, the repeat. You can see what 

157
00:11:09,360 --> 00:11:13,590
this is meant to be. There's settings followed by a bunch of key value pairs. Now, 

158
00:11:13,590 --> 00:11:17,880
the thing that's actually repeating are the key value pairs, not the settings node. 

159
00:11:18,300 --> 00:11:24,720
And in the GPT four, it's got repeat as true to the settings. Whereas here it's got 

160
00:11:24,720 --> 00:11:30,870
an array of nodes of which they have typed setting. It is repeatable and it has a 

161
00:11:30,870 --> 00:11:36,270
declarative key. The declarative key means that rather than saying setting plus a 

162
00:11:36,270 --> 00:11:40,260
key and a value, the actual method name is the key, 

163
00:11:40,330 --> 00:11:44,650
and then it's followed by a positional value that we can see right here. And then 

164
00:11:44,650 --> 00:11:50,140
we see a lack of information purely because we're now not including the actual values 

165
00:11:50,140 --> 00:11:51,340
that were found in the DSL. 

166
00:11:51,130 --> 00:11:55,210
let's look at settings versus prompts. 'cause there's some subtle differences going 

167
00:11:55,210 --> 00:11:59,890
on here. The first is that there is a repeating prompt here. There is a repeating 

168
00:11:59,890 --> 00:12:05,860
setting, but in this place, the method name becomes the key. Whereas this doesn't 

169
00:12:05,860 --> 00:12:11,470
happen in this one. It instead takes a name as a positional parameter, followed by 

170
00:12:11,470 --> 00:12:16,120
a named value called content, which will take a value as well. 

171
00:12:16,130 --> 00:12:20,620
if we move down and we look at what it's done, we can see that it's removed node, 

172
00:12:20,620 --> 00:12:24,820
which is great, and it's moved repeat to the correct location. 

173
00:12:24,830 --> 00:12:27,890
this time, rather than being declarative, it's positional. 

174
00:12:27,900 --> 00:12:33,780
followed by that it's got a named type with a default value of empty string. 

175
00:12:33,800 --> 00:12:38,700
One of the simplistic rules that I have in my documentation is that there's no need 

176
00:12:38,700 --> 00:12:43,170
to state whether something's required or not. If it has a default, it's optional. 

177
00:12:43,660 --> 00:12:47,880
closing off this analysis, we've got the sections, we've got the steps, and we can 

178
00:12:47,880 --> 00:12:50,580
see that being mapped correctly 

179
00:12:50,600 --> 00:12:55,600
simpler because we don't have the extra versions going on. And then if we get down 

180
00:12:55,600 --> 00:12:58,240
to the bottom, let's see what it's done with actions, 

181
00:12:58,260 --> 00:13:02,460
and this is great. It's just got an array of nodes. One is called save. It doesn't 

182
00:13:02,460 --> 00:13:07,500
take any parameters, and one is called Save. Jason. It does take a positional parameter 

183
00:13:07,500 --> 00:13:08,220
called path.

184
00:13:08,230 --> 00:13:11,440
Let's now move into tokenizing and passing 

185
00:13:11,230 --> 00:13:16,450
Now it's given us some starter code, but there's no logic going on here. This is 

186
00:13:16,450 --> 00:13:19,510
basically identifying the strings, the tokens, 

187
00:13:19,530 --> 00:13:25,750
when a block starts, when a block ends, and turning it into a list of tokens that 

188
00:13:25,750 --> 00:13:27,130
can be used by 

189
00:13:27,160 --> 00:13:33,190
the passer, which is down below. So it takes as a parameter, a list of tokens, and 

190
00:13:33,190 --> 00:13:35,970
then the rules and the rules are embodied in the schema

191
00:13:36,800 --> 00:13:40,990
So let's have a look at how that fits with the existing code. So with the tokenize, 

192
00:13:40,990 --> 00:13:47,230
what we're trying to do is work with the particular DSL that we've got in this case, 

193
00:13:47,260 --> 00:13:51,820
the workflow one. And we're trying to separate the concepts like the first definition 

194
00:13:51,820 --> 00:13:57,760
node, which is called workflow. There's a field or a value going in here. There's 

195
00:13:57,760 --> 00:13:58,510
a start of a block. 

196
00:13:58,530 --> 00:14:02,180
at the very bottom, there should be the end of a block. So these are the different 

197
00:14:02,180 --> 00:14:06,440
tokens we're trying to get. Do we have a method? Do we have a string? Do we have 

198
00:14:06,440 --> 00:14:10,160
a symbol further on if there happened to be integers. 

199
00:14:10,330 --> 00:14:12,660
count is three and active 

200
00:14:12,660 --> 00:14:13,630
is true, 

201
00:14:13,630 --> 00:14:19,630
we would want to be able to read that out and notice when we've got a Boolean 

202
00:14:18,930 --> 00:14:19,310
value, 

203
00:14:18,960 --> 00:14:20,130
an integer sort of 

204
00:14:20,330 --> 00:14:22,190
when we've got a positional parameter 

205
00:14:22,200 --> 00:14:27,150
this is what the tokenize is designed to do. But if you move down a bit further and 

206
00:14:27,150 --> 00:14:28,380
look at the paer, again, 

207
00:14:28,400 --> 00:14:34,120
it's going to take the stream of tokens that we got from this particular file and 

208
00:14:34,120 --> 00:14:39,100
work through the schema definition. And the schema definition is going to be read 

209
00:14:39,100 --> 00:14:43,300
out of this file. So it's going to look for a concept like definition, which has 

210
00:14:43,300 --> 00:14:47,170
workflow and try to match it to the DSL, which also has workflow. 

211
00:14:47,200 --> 00:14:53,840
if we zoom in on this section here, what we can see is that there's a search for 

212
00:14:53,840 --> 00:14:59,150
a due block and there's an expectation that there's an end block after it and there's 

213
00:14:59,150 --> 00:15:03,890
a recursion going on. The parse node is calling back through to this method. 

214
00:15:03,900 --> 00:15:08,680
hopefully it's going to split out each of these do blocks and the end blocks and 

215
00:15:08,680 --> 00:15:13,770
capture all the information in between. A bit further on in this particular parser 

216
00:15:14,110 --> 00:15:17,170
is other information like parsing the parameters. 

217
00:15:17,200 --> 00:15:22,440
there would need to be a mechanism in here to make sure that the parameters coming 

218
00:15:22,440 --> 00:15:27,600
through in the DSL match the rules coming through in the DSL definition. 

219
00:15:27,630 --> 00:15:31,440
as we scroll a bit further down into this 

220
00:15:31,460 --> 00:15:36,520
code that's been generated, we can see how it would be called. So the DSL code would 

221
00:15:36,580 --> 00:15:41,920
read through from the DSL that we've written, and from there it would be tokenized 

222
00:15:41,920 --> 00:15:45,820
that the tokens would come through. They would then be passed in with the schema 

223
00:15:45,560 --> 00:15:49,580
which would pass it. And then we could have a look at the output stream after that. 

224
00:15:49,600 --> 00:15:53,760
the considerations that we're seeing here, they're going to be really useful 

225
00:15:53,560 --> 00:15:55,120
in the future of this project 

226
00:15:55,100 --> 00:16:01,420
this is going to be written using cursor and Cursor will rely on a lot of this documentation 

227
00:16:01,420 --> 00:16:03,980
and ideas to write the correct code. 

228
00:16:04,00 --> 00:16:08,540
I was looking through this, one of the areas that I didn't notice was the ability 

229
00:16:08,540 --> 00:16:12,410
for it to deal with self-closing nodes. So I have no, 

230
00:16:13,330 --> 00:16:18,560
such as the three that are listed here, or any of these ones that don't have a do 

231
00:16:18,740 --> 00:16:22,100
or an end block, they just have a carriage return at the end of the 

232
00:16:22,200 --> 00:16:23,600
that's the end of that node.

233
00:16:23,600 --> 00:16:28,190
But what's interesting when you come back to the code that's been generated, they've 

234
00:16:28,190 --> 00:16:33,420
got a fourth area writing a parcel without external libraries. If we zoom in on that, 

235
00:16:33,770 --> 00:16:35,970
we can see simple DSL parser, 

236
00:16:36,00 --> 00:16:41,250
and there's a case statement going on with three different areas. It's looking for 

237
00:16:41,250 --> 00:16:45,940
the do block, it's looking for the end block, and it's looking for the self-closing 

238
00:16:45,940 --> 00:16:46,210
parramater. 

239
00:16:46,230 --> 00:16:51,850
I'm not exactly sure how this simple DSL parser that we've got here relates to the 

240
00:16:51,900 --> 00:16:56,470
tokenize and the parser above, but at least it's thought about these codes and we 

241
00:16:56,470 --> 00:17:02,500
can analyze it a bit further if we move on. It also gives a whole lot of extra information 

242
00:17:02,500 --> 00:17:08,440
that'll be used by the pair programmer when I'm using Cursor or Claude Dev to generate 

243
00:17:08,440 --> 00:17:08,820
the code.

244
00:17:08,830 --> 00:17:11,150
it's giving further insight, which is 

245
00:17:11,330 --> 00:17:16,420
represented in the requirements document, but also added to this area around passing 

246
00:17:16,420 --> 00:17:21,490
parameters, the position or the named and the declarative. It doesn't talk too much 

247
00:17:21,490 --> 00:17:25,510
about the splats or the double splats, but that's in the requirements document. We've 

248
00:17:25,510 --> 00:17:30,730
got the repeat flag, which is when a node can be repeated multiple times. 

249
00:17:30,760 --> 00:17:34,860
and then we've got a pros and cons in using this particular technique. 

250
00:17:34,860 --> 00:17:40,280
now the additional considerations are more useful for the JavaScript wrapper. That'll 

251
00:17:40,280 --> 00:17:44,540
be used by Visual Studio, but it's good that the information is kept here. 

252
00:17:44,560 --> 00:17:47,480
finally, we have a conclusion and next steps. 

253
00:17:47,490 --> 00:17:51,550
So I've grabbed all the information here and we've come over to Visual Studio. I've 

254
00:17:51,550 --> 00:17:57,190
got a file called Brief and we can see all the information that was in the original 

255
00:17:57,190 --> 00:18:02,680
chat. GPT window has been made available in a markdown document. This will be good 

256
00:18:02,680 --> 00:18:08,560
for when I use Cursor to build the application. And I've gone and started the implementation 

257
00:18:08,740 --> 00:18:12,850
by just copying the code and just wrapping some name spacing around it. So we've 

258
00:18:12,850 --> 00:18:18,400
got the pa, we've got the tokenize, and I've just left the sample usage right here. 

259
00:18:18,700 --> 00:18:24,130
Now this particular project that we are looking at, I've just gone and uploaded it. 

260
00:18:24,340 --> 00:18:30,340
So there's a new version. I did it as a feature. So if I just go to my gen, we should 

261
00:18:30,340 --> 00:18:36,970
be able to see a new version of it. We're at version one. If we click on it, you 

262
00:18:36,970 --> 00:18:41,320
should be able to access it yourself going to the GitHub repo. 

263
00:18:41,330 --> 00:18:46,350
So the feature six minutes ago has been added. You can find the documentation here. 

264
00:18:46,350 --> 00:18:47,370
You can find 

265
00:18:47,390 --> 00:18:49,740
the code within this section. 

266
00:18:49,760 --> 00:18:55,750
Other things to notice about this is that I use DSLs all the time for different problem 

267
00:18:55,750 --> 00:18:57,490
domains. For instance, I 

268
00:18:57,490 --> 00:19:02,150
story cards. And the project plan is written creating a DSL. 

269
00:19:01,960 --> 00:19:06,490
gets visualized using Draw io, which is a graphing tool. 

270
00:19:06,490 --> 00:19:10,930
we can see some of the things that we wanna work on in this particular project being 

271
00:19:10,930 --> 00:19:12,130
displayed right here. 

272
00:19:12,160 --> 00:19:14,870
you can just come and pull it from this 

273
00:19:14,890 --> 00:19:15,760
Git repo. 

274
00:19:15,760 --> 00:19:21,430
in the next video what we're going to do is continue building this sample project. 

275
00:19:21,220 --> 00:19:26,320
It's part of a bigger project where I've got visual studio code extensions, we've 

276
00:19:26,320 --> 00:19:31,210
got Monaco extensions and a programming language that I'm developing called KlueLess, 

277
00:19:31,690 --> 00:19:33,430
where the clue is to do less. 

278
00:19:33,430 --> 00:19:37,890
I am Appy Dave, please like and subscribe and I look forward to seeing you in the 

279
00:19:37,890 --> 00:19:37,800
next video.